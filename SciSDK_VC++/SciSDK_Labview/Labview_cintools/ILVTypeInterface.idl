cpp_quote("// ==================================================================")
cpp_quote("// NI CONFIDENTIAL													")
cpp_quote("// (c) Copyright 2006-2008 by National Instruments Corp.				")
cpp_quote("// All rights reserved.												")
cpp_quote("//																	")
cpp_quote("// @file		ILVTypeInterface.idl									")
cpp_quote("// @brief	Interface definitions for LabVIEW types.				")
cpp_quote("//			The files ILVTypeInterface_i.c and ILVTypeInterface.h	")
cpp_quote("//			are generated using this ILVTypeInterface.idl.			")
cpp_quote("// ==================================================================")

//============================================================================
// Imports
//============================================================================

import "unknwn.idl";

//============================================================================
// Interface forward declarations.
//============================================================================

interface ILVData;
interface ILVString;

//============================================================================
// cpp_quotes
//============================================================================

cpp_quote("#include \"extcode.h\"")

// fundtypes.h will be included in extcode.h so we do not want a redefinition
// in the generated files. #if out the code generated by the #include of
// fundtypes.h below.
cpp_quote("#ifndef _fundtypes_H")
#define _WCHAR_T_DEFINED	1
#include "fundtypes.h"
typedef int32 MgErr; // defined in extcode.h
cpp_quote("#endif // ifndef _fundtypes")


// ============================================================================
// Pure virtual base interface for LabVIEW type descriptors.
// ============================================================================
[
	object, local,
	uuid(09a66b9c-3683-4f5c-b4ce-b7e428fc3914),
	helpstring("ILVTypeDescriptor"),
	pointer_default(unique)
]

/** 
	@brief Base class for the LabVIEW type descriptor interface
*/
interface ILVTypeDescriptor : IUnknown
{
	/** 
		@brief Compares two LabVIEW type descriptors.
		@return The error as an MgErr.
	*/
	MgErr Compare(
		[in] ILVTypeDescriptor* type,	///< The type to compare this type with
		[out] int32* retVal				///< Outputs zero if the types are equal and non-zero if they differ
		);

	typedef enum {
		kCompareDefaultCheck	= 0,	///< Default behavior. Ignore name differences. TypeDefness (is or is not a typedef) difference, typeDef name, and time stamp difference reported as 0x1 for convert allowed.
		kCompareAllNameCheck	= 0x1,	///< Names in type descriptor must match exactly.
		kCompareSubNameCheck	= 0x2,	///< Names below top-level of type descriptor must match exactly.
		kCompareNoTypeDefCheck	= 0x8	///< Whether or not it is a typeDef or typeDef name or time stamp differences ignored.
	} CompareWithOptionMasks;

	/** 
		@brief Compares two LabVIEW type descriptors with options.
		@return The error as an MgErr.
	*/
	MgErr CompareWithOptions(
		[in] ILVTypeDescriptor* type, 	///< The type descriptor to compare with the this type.
		[in] int32 compareOptions,		///< Options to control the type descriptor comparison. These are flags from the enum CompareOptionMasks.
		[out] int32* retVal				///< Outputs zero if the type are equal and non-zero if they differ.
		);

	/** 
		@brief Get an integer value that represents the type of the data. This can be useful for simple data types.

		Some values of the type code returned include:
			0x00 - void code
			0x01 - integer byte
			0x02 - integer word
			0x03 - integer long
			0x04 - integer quad
			0x05 - unsigned integer byte
			0x06 - unsigned integer word
			0x07 - unsigned integer long
			0x08 - unsigned integer quad
			0x09 - single precision float
			0x11 - double precision float
			0x12 - extended precision float
			0x13 - complex single precision
			0x14 - complex double precision
			0x15 - complex extended precision
			0x21 - boolean
			0x30 - string
			0x32 - path
			0x40 - array
			0x50 - cluster
			0x53 - LV variant
			0x54 - measurement data
			0x5F - fixed point number 
			0x70 - refnum
		@return The error as an MgErr.
	*/
	MgErr GetTypeCode(
		[out] int16* typeCode	///< Type code output.
		);
		   
	/** 
		@brief Get a pointer to the internal LabVIEW type descriptor. 
		@return The error as an MgErr.
	*/
	MgErr GetInternalLVTypeDescriptor(
		[out] void** ppInternalTypeDesc		///< Outputs a pointer to the internal LabVIEW type descriptor. (Here, void** is equivalent to TDR**)
		);
};

// ============================================================================
// Interface for a LabVIEW boolean type descriptor.
// ============================================================================
[
	object, local,
	uuid(234324FE-6E30-4cca-98F0-155793F2C682),
	helpstring("ILVBooleanTypeDescriptor"),
	pointer_default(unique)
]

interface ILVBooleanTypeDescriptor : ILVTypeDescriptor
{
}

// ============================================================================
// Interface for a LabVIEW numeric type descriptor.
// ============================================================================
[
	object, local,
	uuid(da09ad59-f1b8-46b3-aba0-4b48c98a8afb),
	helpstring("ILVNumericTypeDescriptor"),
	pointer_default(unique)
]

/** 
	@brief Type descriptor interface interface class for numerics.
*/
interface ILVNumericTypeDescriptor : ILVTypeDescriptor 
{
	typedef enum {
		kNonNumericInterfaceCode = 0,
		kInt8InterfaceCode, 
		kInt16InterfaceCode, 
		kInt32InterfaceCode, 
		kInt64InterfaceCode,
		kUInt8InterfaceCode, 
		kUInt16InterfaceCode, 
		kUInt32InterfaceCode, 
		kUInt64InterfaceCode,
		kFloat32InterfaceCode, 
		kFloat64InterfaceCode,
		kFloatExtInterfaceCode,
		kComplex64InterfaceCode,
		kComplex128InterfaceCode,
		kComplexExtInterfaceCode
	} NumericInterfaceCode;

	/** 
		@brief Get an integer value that represents the type of the data.
		@return The error as an MgErr.
	*/
	MgErr GetNumericCode(
		[out] NumericInterfaceCode* numericCode	///< Numeric type code output
		);
	
	//Enum related functions

	/// Does this numeric have enum attributes
	Bool32 IsEnum();

	/** 
		@brief For enums, get the number of elements in the enumerated type.
		@return The error as an MgErr.
	*/
	MgErr GetEnumNumElements(
		[out] uInt32* numElements	///< Output the number of elements in the type
		);

	/** 
		@brief For enums, get the name of an element in the enumerated type found at the specified position.
		@return The error as an MgErr.
	*/
	MgErr GetEnumElementName(
		[in] uInt32 position,				///< The index of the element in the enumerated type 
		[out] const uChar** elementName,	///< Name of the element
		[out] size_t* elementNameLength		///< Length of the string
		);
	
	/** 
		@brief For enums, get the name of an element in the enumerated type found at the specified position.
		@return The error as an MgErr.
	*/
	MgErr GetEnumElementNameILVString(
		[in] uInt32 position,				///< The index of the element in the enumerated type 
		[out] ILVString ** elementName		///< Name of the element
		);

	/** 
		@brief For enums, get the number of an element in the enumerated type based upon its name.
		@return The error as an MgErr.
	*/
	MgErr GetEnumElementNumber(
		[in] const uChar* elementName,		///< Name of the element
		[in] size_t elementNameLength,		///< Length of the string
		[out] uInt32* position				///< The index of the element in the enumerated type 
		);

	/** 
		@brief For enums, get the number of an element in the enumerated type based upon its name.
		@return The error as an MgErr.
	*/
	MgErr GetEnumElementNumberILVString(
		[in] ILVString * elementName, 		///< Name of the element
		[out] uInt32* position				///< The index of the element in the enumerated type 
		);
};

// ============================================================================
// Interface for a LabVIEW array type descriptor.
// ============================================================================
[
	object, local,
	uuid(c2d6f738-f5b3-4db1-a1fa-5672fdeaf60f),
	helpstring("ILVArrayTypeDescriptor"),
	pointer_default(unique)
]

/** 
	@brief Type descriptor interface interface class for arrays.
*/
interface ILVArrayTypeDescriptor : ILVTypeDescriptor 
{
	/** 
		@brief Get the type descriptor for the array elements.
		@return The error as an MgErr.
	*/
	MgErr GetElementTypeDescriptor(
		[out] ILVTypeDescriptor** elementTypeDescriptor		///< element type descriptor output
		);

	/** 
		@brief Get the number of dimensions for the array.
		@return The error as an MgErr.
	*/
	MgErr GetNumDimensions(
		[out] uInt32* numDimensions		///< Output the number of dimensions
		);
};

// ============================================================================
// Interface for a LabVIEW string type descriptor.
// ============================================================================
[
	object, local,
	uuid(7b4ef86e-e843-41f4-a4d8-88a2f2372365),
	helpstring("ILVStringTypeDescriptor"),
	pointer_default(unique)
]

/** 
	@brief Type descriptor interface interface class for strings.
*/
interface ILVStringTypeDescriptor : ILVTypeDescriptor
{
	/// Returns TRUE if the length of the string has a variable size
	Bool32 IsVariableSize(void);

	/// Returns TRUE if the max length of the string is bounded to a positive - greater or equal to 0 - value. 
	Bool32 IsBoundedSize(void);

	/// Returns TRUE if the length of the string is fixed
	Bool32 IsFixedSize(void);

	/** 
		@brief Get the number of elements for which memory has been allocated.

		For variable length strings - returns -1
		For fixed/bounded length strings - equals to the bounded/fixed size
		@return The error as an MgErr.
	*/
	MgErr GetCapacity(
		[out] size_t* size		///< Output capacity
		);
};

// ============================================================================
// Interface for a LabVIEW cluster type descriptor.
// ============================================================================
[
	object, local,
	uuid(fc873d27-ad8e-45da-bd26-e3f42c3d8157),
	helpstring("ILVClusterTypeDescriptor"),
	pointer_default(unique)
]

/** 
	@brief Type descriptor interface interface class for clusters.
*/
interface ILVClusterTypeDescriptor : ILVTypeDescriptor
{
	/** 
		@brief Get the number of elements in the cluster
		@return The error as an MgErr.
	*/
	MgErr GetNumElements(
		[out] uInt32* numElements		///< Output the number of elements in a cluster
		);

	/** 
		@brief Get the number of elements in the cluster by recursively counting into the subclusters
		@return The error as an MgErr.
	*/
	MgErr GetNumElementsRecursive(
		[out] uInt32* numElements		///< Output the number of elements in a cluster and its subclusters
		);

	/** 
		@brief Get the type descriptor for the element at a specified position.
		@return The error as an MgErr.
	*/
	MgErr GetElementTypeDescriptor(
		[in] uInt32 position,								///< The index of the element we are accessing 
		[out] ILVTypeDescriptor** elementTypeDescriptor		///< The type descriptor of the element specified by position
		);

	/** 
		@brief Gets the name of an element in the cluster.
		@return The error as an MgErr.
	*/
	MgErr GetElementName(
		[in] uInt32 position,			///< The index of the element we want the name of
		[out] ILVString** name			///< The element's name as an output
		);
	
	/** 
		@brief Gets the index of an element in the cluster based upon the element's name.
		@return The error as an MgErr.
	*/
	MgErr GetElementIndex(
		[in] ILVString* name,			///< The name of the element we want the index of
		[out] int32* index				///< The index of the element with that name
		);
};
